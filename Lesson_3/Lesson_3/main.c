#include <stdio.h>
#define N 10 // макрос: при написании N в программу, компилятор подставит 100 при её запуске

void Cycles_Examples(void) // ЦИКЛЫ
{
    // for(начальное значение счетчика; условие, при котором работает цикл; шаг изменения счетчика) {тело цикла}
    // for( ; ; ) - безусловный "бесконечный" цикл
    //
    // while(условие) {тело цикла}
    // while(1) - "бесконечный" цикл
    //
    // do{тело цикла} while(условие) - тело цикла выполнится хотя бы один раз
    //
    // break; - чтобы выйти из цикла

    // если надо выполнить тело цикла N раз
    
    int count = 0;
    for(int i = 1; i <= N; i++)
    {
        count++;
        printf("%d ", count);
        
    }
    printf("\n");
    
    // или
    
    count = 0;
    int i = 0;
    while(i < N)
    {
        i++;
        count++;
        printf("%d ", count);
    }
    printf("\n");
    
    // завершение цикла с break;
    count = 0;
    while(1)
    {
        count++;
        if (count >= N) // Но! если условие можно проверять в while, то надо делать это там
            break; // чтобы выйти из цикла
    }
    
    return;
}

// КАК СЧИТЫВАТЬ В ЦИКЛЕ?
int While_getchar_sum_example(void)
{
    int symbol = 0;
    int Sum = 0;
    int count_error = 0; //счётчик для отслеживания ошибок ввода
    
    while((symbol = getchar()) != '\n') // обратите внимание на порядок операций - скобки важны
    {
        count_error++;
        
        if ((symbol >= '0') && (symbol <= '9')) // проверить, что ввели цифру
            Sum = Sum + (symbol - '0'); // symbol - '0' - получить не код символа обозначающего цифру, а саму цифру
        else
            printf("Error - %d symbol isn't digit\n", count_error);
    }
    return Sum;
}

// БИНАРНЫЕ ОПЕРАЦИИ
void Binary_example(void)
{
    int x = 3, y = 5, z;

    z = x & y; // AND    // 0011 & 0101 = 0001
    z = x | y; // OR     // 0011 | 0101 = 0111
    z = x ^ y; // XOR    // 0011 ^ 0101 = 0110

    z = x & 0x00000004; // применить маску, чтобы вычленить 3й с конца бит числа x // т.к. 0x4 = 0100 - бинарное

    z = x >> 1; // 0011 -> 0001 // сдвиг вправо на 2 позиции, как бы деление на 2 в степени 1
    z = x << 2; // 0011 -> 1100 // сдвиг влево на 2 позиции,  как бы умножение на 2 в степени 2

    x = 1;                    // 0x00 00 00 01    // 0...0 0000 0001 - если в бинарном виде
    z = ~x; // отрицание     // 0xff ff ff fe    // 1...1 1111 1110 - если в бинарном виде

    return;
}

// КАК ПОДСЧИТАТЬ КОЛИЧЕСТВО ЕДИНИЦ В БИНАРНОЙ ЗАПИСИ ПОЛОЖИТЕЛЬНОГО ЧИСЛА
int Count_number_of_1(int x)
{
    int number_of_1 = 0;

    // способ 1
    while(x > 0)
    {
        number_of_1 = number_of_1 + (x & 0x01); // взять младший бит и прибавить его значение к number_of_1
        x = x >> 1; // сдвиг, чтобы проверить следующий бит
    }

    // способ 2
    for(; x > 0; x = x & (x-1))
    {
    // не указываем счетчик, т.к. начальное значение x уже задано
    // работаем до тех пор пока x не станет 0
    // при переходе на следующую итерацию меняем значение x по формуле x = x & (x-1)
    // x & (x-1) - обнуляет младший единичный бит числа x
    // например, если x = 0011, то x & (x-1) = 0011 & 0010 = 0010
    // например, если x = 1100, то x & (x-1) = 1100 & 1011 = 1000
        number_of_1++; // просто подсчитаем, сколько раз произошло обнуление
    }

    return number_of_1;
}

int main()
{

    Cycles_Examples();
    
    printf("Sum = %d\n", While_getchar_sum_example());

    Binary_example();

    int x;
    scanf("%d", &x);
    printf("number_of_1 = %d\n", Count_number_of_1(x));
    
    return 0;
}

