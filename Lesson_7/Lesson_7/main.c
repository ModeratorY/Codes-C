// Функции и области видимости

#include<stdio.h>
#include<stdlib.h>
#define N 10

// ============================================================================

// Место для объявления (declaration) глобальных переменных
int X, Y;
int ARR[N];

/* Глобальные переменные:
    - доступны всем функциям (из этого файла)
    - место под них зарезервировано в бинарном файле
    (а он подгружается в память непосредственно перед запуском программы) =>
    - изначально = 0
    - размер определен во время компиляции
    - лежат недалеко от кода
    - срок их жизни ограничен сроком жизни программы
*/

// Определение функций

void Func_ARR(void);

void Func_print(int a);

double Func_mul(double a, double b);

int Func_sum(int a, int b);

void Func_print_adr(int a);

void Func_change(int * p);

int Find_p_i(int *p, int i);

// ============================================================================

// Вызов функций в main

int main()
{

    Func_ARR(); // функция без аргументов и она не возвращает значение
    
    printf("In main: ARR[0] = %d\n", ARR[0]);
    // т.к. глобальные переменные доступны из всех функций
    
    printf("================================================\n");

    int x = 7, z = 0;
    printf("In main: z = %d\n", z);
    
    z = Func_sum(x, 6);
    // вызываем функцию по имени
    // если функция что-то возвращает, это что-то
    // надо записать в переменную и проанализировать
    
    printf("In main after Func_sum: z = %d\n", z);
    
    printf("================================================\n");

    Func_print_adr(z);
    printf("In main: local variable z = %d has address %p\n", z, &z);
    // Пример показывает, что z - аргумент func_print_adr и z - локальная переменная main - это разные вещи
    
    printf("================================================\n");
    
    // изменить переменную z, используя "передачу значения в функцию по указателю"
    Func_change(&z);
    printf("In main: z = %d\n", z);
    // при вызове функции, в нее в по-прежнему передается КОПИЯ ЗНАЧЕНИЯ аргумента
    // но сам аргумент в данном случае, это указатель на переменную z
    // то есть, мы передали в функцию КОПИЮ АДРЕСА переменной z
    // а зная адрес переменной (имея указатель на нее) можем внутри функции изменять значение переменной z
    
    printf("================================================\n");

    int *p; // зарезервировали память под указатель на x
    p = &x; // положили туда адрес x, теперь p - указатель на x
    
    // вызовем функцию
    Func_change(p);
    
    printf("In main: x = %d\n", x);
    // все тоже самое, что и в предыдущем примере
    
    /*
    Динамическое выделение памяти
        - выделяется на куче ("heap" - термин в ОС)
        - живет пока, не будет вызвана free(p);
        - доступна всем, кто имеет на нее указатель
    */
    
    // выделили память динамически
    int n = 10;
    int *q = (int *) malloc(sizeof(int) * n);
    
    // передали указатель на нее в функцию
    z = Find_p_i(q, 4); // в данном случае q[4] будет лежать муссор
    printf("In main: q[0] = %d\n", q[0]); // эта ячейка была изменена при работе find_p_i
    
    free(q);

    return 0;
}

// ============================================================================

// Описание функций
// тип_возвращаемого_значения имя_функции(тип_аргумента сам_фргумент);

void Func_ARR(void) // функция без аргументов и не возвращает значение
{
    ARR[0] = 9;
    // это будет корректно
    // т.к. глобальные переменные доступны из всех функций
    
    return; // выход из функции, дальнейшее прекращение кода в этой функции типа void
}

void Func_print(int a) // возвращает значение, один аргумент типа int
{
    printf("In func_print: argument = %d\n", a);
    
    // a = 0; ! а вот так делать не надо ! во-первых,
    // когда функция отработает, это значение будет потеряно

    return;
}

double Func_mul(double a, double b) // 2 аргумента, и возвращаемое значение типа double
{
    return a * b;
}

int Func_sum(int a, int b)
{
    // Место для создания локальных переменных
    int c;
    c = a + b;
    
    return c;
}

/* Локальные переменные:
    - существуют только внутри той функции, в которой объявлены
    - место под них зарезервировано в стеке (см. стек вызовов функций) =>
    - могут содержать любой мусор
    - существуют только пока функция работает
    - если запускать вызовы функции рекурсивно, то каждый раз это будет разные переменные
*/

/* Аргументы
    - при вызове функции, в нее в передается КОПИЯ ЗНАЧЕНИЯ аргумента
    - аргументы, как и локальные переменные, существуют только пока работает функция
*/

// Это еще называется "передача аргумента по значению"

void Func_print_adr(int a)
{
    printf("In func_print_adr: argument = %d has address %p\n", a, &a);
    
    // изменять a здесь было бы бессмысленно
    // (это значение будет потеряно, как только функция завершится)
    // и вообще, плохой тон
    
    return;
}

// Если надо внутри функции изменять какую-то внешнюю переменную,
// то она должна быть либо глобальной,
// либо в функцию в качестве аргумента надо передать ее адрес (указатель на нее)
// Это еще называется "передача аргумента по указателю"

void Func_change(int * p) // передали адрес переменной p
{
    *p = 5;
    
    // зная указатель на переменную (ее адрес) можем изменить
    // значение переменной, на которую он указывает
    
    return;
}

// Пример, обращение к массиву по указателю

int Find_p_i(int *p, int i)
{
    printf("In find_p_i: p[%d] = %d\n", i, p[i]);
    p[0] = 8; // так тоже можно, т.к. мы обращаемся к памяти, используя указатель p
    return p[i];
}
