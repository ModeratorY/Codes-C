// Указатели

#include <stdio.h>
#include <stdlib.h>


void func_for_pointers(void);

int main()
{
    // Указатель можно рассматривать как ячейку памяти, которая хранит в себе адрес переменной. Мы можем обращаться к переменной (или просто к области памяти), зная ее адрес.
    
    // Пример
    int a = 7;  // создали переменную a, т.е. выделили под нее память (4 байта) и записали в нее какое-то значение
    int * p;    // создали переменную p, которая может потом служить указателем на некую переменную типа int
    p = &a;     // записали в переменную p адрес переменной a. Теперь, можно сказать, что p - указатель на a.
    *p = 8;     // "разыменование указателя": берем адрес из p, проходим по нему (попадаем в a) и записываем 8
    printf("a = %d\n", a);
    // размер указателя, sizeof(p), стандартный и зависит от архитектуры процессора и ОС (в 64-битных системах - 8 байт)

    // Типы
    // указатель декларируется как:
    // тип_того,_на_что_он_должен_указывать * имя;
    
    // или
    
    void * name;    // если не известен размер переменной, адрес которой лежит в указателе

    // & и *
    // &x - позволяет получить адрес переменной x
    // *p - позволяет обратиться (прочитать или записать что-то) по адресу, который записан в p
    
    printf("====================================\n");
    
    func_for_pointers();
    
    printf("====================================\n");
    
    // Еще раз про динамическое выделение памяти
    // Пример динамического выделения памяти под строку
    
    int n;
    printf("Введи размер malloc = ");
    scanf("%d", &n);
    char * p2 = (char*) malloc(n); // выделить память, ровно m байт, так как sizeof(char) = 1 байт
                                  // или лучше char *p = (char*) malloc(sizeof(char) * m);
    
    if (p2 == NULL)        // если функция в принципе может вернуть ошибку, надо делать проверку ошибок
        printf("ERROR");
    
    /*
        Вызвали ф-цию malloc из библиотеки stdlib.h,
        malloc(m) выделит непрерывный кусок памяти размером m байт, и вернет указатель на него.
        malloc возвращает указатель типа void*, т.е., не знает как эта память будет использоваться
        в дальнейшем.
        Поэтому, нужно сделать приведение типов (char*) перед использованием (например, присваиванием).
        Это позволит потом обращаться к элементам массива как p[i]
    */
    
    p2[n-1] = '\0';              // если хотим использовать как строку, нужно поставить символ конца строки в конце
    
    getchar(); // считываем здесь 1 раз getchar() потому что в потоке ввода есть символ \n в 44 строке
    
    for(int i = 0; i < n-1; i++)
    {
        p2[i] = getchar(); // заполняем массив
    }
    
    printf("%s\n", p2);    // распечатать строку, лежащую по адресу p
    
    free(p2);    // обязательно необходимо освободить память после
        
    return 0;
}

// Можно делать указатели на указатели
void func_for_pointers(void)
{
    // выделить память под переменные
    //(в данном случае, это локальные переменные функции, и память под них выделяется на стеке)
    int a = 10;
    int * b;
    int ** c;
    int *** d;
    
    printf("at first a = %d\n", a);
    
    // создать связи
    b = &a;        // теперь b - указатель на a (указатель на a)
    c = &b;        // теперь c - указатель на b (указатель на указатель на a)
    d = &c;        // теперь d - указатель на d (указатель на указатель на указатель на а)
    
    // обратиться к a, используя d
    
    ***d = 0;    // в итоге в a будет записан 0
    
    // выражение ***d разбирается справа налево: ***d = **(*d) = **c = *(*c) = *b = a
    
    printf("then a = %d\n", ***d);
    
}





