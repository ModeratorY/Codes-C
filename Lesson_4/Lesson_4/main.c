// arrays - массивы
int arr[100]; // чтобы создать статический массив из 100 последовательных элементов, каждый из которых имеет тип int
// таким образом можно создать массив как глобально, так и локально
// Этот массив - статический. Это важно, т.к. его размер должен быть известен на этапе компиляции

// Например:
/* делать вот так - НЕЛЬЗЯ (в чистом Си)
 
    int n;
    scanf("%d", &n);
    int arr[n]; // в чистом Си это ОШИБКА - попытка создать статический массив неизвестной длины

    Ошибка тут в том, что длина массива должна быть известна компилятору заранее, т.е. задолго до запуска программы
    и ввода пользователем какого-либо значения
 
*/

#include <stdio.h>
#include<stdlib.h>
#include <string.h>

#define N 100
#define L 20
#define M 10
#define cnt 5

int main()
{
    // создать массив можно 2мя способами:

    // 1) как статический массив
    
    int arr[N];
    
    // а обращаться к его элементам как
    arr[0] = 0;
    // Нумерация в массиве начинается с 0. То есть, в массиве есть элементы с номерами от 0 до 99 в данном случае.
    // пройти по всем элементам массива
    for(int i = 0; i < N; i++)
    {
        arr[i] = i;
        printf("%d ", arr[i]);
    }
    printf("\n");
    
    printf("==========================================\n");
    
    // 2) как динамический массив
    // для этого понадобится библиотека <stdio.h>
    
    int n;
    scanf("%d", &n);
    
    if (n <= 0)
        return 0;
    
    // динамически выделить память под массив
    int *p = (int *) malloc (n * sizeof(int));
    
    for(int i = 0; i < n; i++) // заполнение массива
        p[i] = i;
    
    for(int i = 0; i < n; i++) // заполнение массива
        printf("%d ", p[i]);
    
    // не забыть потом освободить память
    free(p); //это делать обязательно, чтобы не было утечки памяти
    
    printf("\n");
    
    printf("==========================================\n");
    
    //пример нахождения максимального элемента в массиве
    
    int arr_2[M] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}; // как-нибудь заполнить массив
    int max;
    
    max = arr_2[0]; // чтобы максимальный элемент гарантировано принадлежал массиву
    
    for(int i = 0; i < M; i++) // пройти по всем элементам
    {
        if (max < arr_2[i])
            max = arr_2[i];
    }
    printf("max = %d\n", max);
    
    printf("==========================================\n");
    
    // можно задавать значения элементов массива при его создании, например
    
    //    int arr[N] = {0}; // обнулить все элементы
    //    int arr[N] = {1}; // нулевой элемент будет =1, остальные при этом не изменяются
    //    int arr[N] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}; // задать значение первым 10 элементам
    //    char str1[] = "Hello\0"; // Комплилятор сам может определить размер массива символов
    
    //    адрес массива можно получить, или используя его имя
    //    arr
    //    или, честно взяв адрес первого элемента
    //    &arr[0]
    
    //================================================================================
    
    // примеры функций работающих с массивами
    
    char src[cnt] = {'1', '2', '3', '4', '5'}; // в src заполняем первые 5 элементов
    char dest[cnt] = {0}; //зануляем весь dest
    
    for(int i = 0; i < cnt; i++)
        printf("%d", dest[i]); // проверим, что dest весь заполнен нулями, для этого печатаем значения элементов как числа
    printf("\n");
    
    // если надо скопировать содержимое одной области памяти (не обязательно массива) в другую
    memcpy(dest, src, cnt);
    // скопировать в кусок памяти, лежащий по адресу dest
    // из куска памяти, лежащего по адресу src
    // количество байт равное 3-му аргументу функции, т.е. в данном случае cnt
    // обязательно надо проверять соответствие размеров, чтобы не скопировать слишком мало, и чтобы не выйти
    // за границы массивов (областей памяти)

    for(int i = 0; i < cnt; i++)
        printf("%c", dest[i]); // опять распечатаем массив, чтобы проверить, что копирование произошло (печатаем как символы)
    printf("\n");
    
    
    memset(dest, 'J', sizeof(dest));
    // начиная с адреса dest заполнить sizeof(dest) байт символами 'J'
    
    for(int i = 0; i < cnt; i++)
        printf("%c", dest[i]); // опять распечатаем массив, чтобы проверить, что заполнение произошло (печатаем как символы)
    printf("\n");
    
    
    // сравнить первые 4 байта из двух областей памяти (например, строк)
    
    if (memcmp(dest, "JJJJJ", 5) == 0) // функция memcmp возвращает 0, если сравниваемые части массивов одинаковы
    {
        printf("First 5 bytes are equal\n");
    }
    
    printf("==========================================\n");
    
    // strings
    // строка - это массив символов, обязательно заканчивающийся символом '\0' - конец строки
    
    // примеры использования
    
    char str1[] = "hello world\0";
    char str2[L] = {0}; // обнулили все элементы
    
    // примеры считывания и печати
    printf("%s\n", str1); // %s - распечатать строку, (будет распечатать пока не встретит \0)
    
    scanf("%s", str2); // %s - считать строку (до ближайшего пробела, перевода строки \n или конца строки \0)
    
    // scanf("%s[^\n]", str2); // %[^\n] - считать как строку - до ближайшего \n
    // scanf("%19s", str2); // %19s - считать первые 19 символов - это удобно, т.к. ввод гарантировано
    // поместится в выделенный участок памяти из 20 байт (19 введенных + 1 '\0')
    
    printf("%s\n", str2);

    // примеры использования функций
    
    // определить длину строки (\0 не считается)
    size_t a = strlen(str1);
    printf("size str1 = %ld\n", a);
    
    // скопировать строку str1 в строку str2
    if (a < L) // надо обязательно заранее проверить, что места достаточно
        strcpy(str2, str1); // в str2 скопировать str1
    
    printf("%s\n", str2);
    
    // найти подстроку в строке, возвращает указатель на начало подстроки
    char * adres = strstr(str1, "world");
    if(adres != NULL)
        printf("%c\n", *adres); //выведется тот символ, который будет началом нашей подстроки

    // Как сравнить 2 строки
    // функция strcmp(str1, str2) работает следующим образом:
    // Функция побайтно сравнивает коды символов двух строк, на которые указывают аргументы функции.
    // Сравнение продолжается до встречи первого отличающегося символа или пока не будут проверены все символы строк.
    // Возвращается:
    // 0 - если все символы в str1 и в str2 одинаковы
    // Значение больше нуля - если символы в строках разные и код символа в str1 больше кода символа в str 2
    // Значение меньше нуля - если символы в строках разные и код символа в str1 меньше кода символа в str 2


    int example = strcmp(str1, str2);
    if (example == 0)
        printf("equal");
    else
    {
        if (example < 0)
            printf("str1 < str2/n");
        else
            printf("str1 > str2/n");
    }
    
    return 0;
}
